<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.12
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1>Qo</h1>

<p><a href="https://travis-ci.org/baweaver/qo"><img src="https://travis-ci.org/baweaver/qo.svg?branch=master" alt="Build Status"></a>
<a href="https://codeclimate.com/github/baweaver/qo/maintainability"><img src="https://api.codeclimate.com/v1/badges/186e9cbb7003842acaf0/maintainability" alt="Maintainability"></a>
<a href="https://badge.fury.io/rb/qo"><img src="https://badge.fury.io/rb/qo.svg" alt="Gem Version"></a></p>

<p>Short for Query Object, my play at Ruby pattern matching and fluent querying, <a href="img/whoa_lemur.png">pronounced &quot;Q-whoah&quot;</a>.</p>

<p><img src="img/qo_logo.png" alt="Qo Lemur logo"></p>

<p><a href="https://baweaver.github.io/qo/">Read the Docs for more detailed information</a></p>

<h2>How does it work?</h2>

<p>Mostly by using Ruby language features like <code>to_proc</code> and <code>===</code>.</p>

<p>There&#39;s an article explaining most of the base mechanics behind Qo:</p>

<p><a href="https://medium.com/@baweaver/for-want-of-pattern-matching-in-ruby-the-creation-of-qo-c3b267109b25">For Want of Pattern Matching in Ruby - The Creation of Qo</a></p>

<p>Most of it, though, utilizes Triple Equals. If you&#39;re not familiar with what all you can do with it in Ruby, I would encourage you to read this article as well:</p>

<p><a href="https://medium.com/rubyinside/triple-equals-black-magic-d934936a6379">Triple Equals Black Magic</a></p>

<p>The original inspiration was from a chat I&#39;d had with a few other Rubyists about pattern matching, which led to this experiment:</p>

<p><a href="https://gist.github.com/baweaver/611389c41c9005d025fb8e55448bf5f5">Having fun with M and Q</a></p>

<p>Fast forward a few months and I kind of wanted to make it real, so here it is. Introducing Qo!</p>

<h2>Usage</h2>

<p>Note that Qo uses the <a href="https://www.github.com/baweaver/any">Any</a> gem for wildcard matching. Any will respond true to any <code>==</code> or <code>===</code> query against it,
and is included in the gem.</p>

<h3>Quick Start</h3>

<p>Qo is used for pattern matching in Ruby. All Qo matchers respond to <code>===</code> and <code>to_proc</code> meaning they can be used with <code>case</code> and Enumerable functions alike:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>case</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>42</span><span class='rbracket'>]</span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Any</span><span class='comma'>,</span> <span class='int'>42</span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Truly the one answer</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>else</span> <span class='kw'>nil</span>
<span class='kw'>end</span>

<span class='comment'># Run a select like an AR query, getting the age attribute against a range
</span><span class='id identifier rubyid_people'>people</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>age:</span> <span class='int'>18</span><span class='op'>..</span><span class='int'>30</span><span class='rbracket'>]</span><span class='rparen'>)</span>
</code></pre>

<p>How about some pattern matching? There are two styles:</p>

<h4>Pattern Match</h4>

<h5>Case Statements</h5>

<p>Qo case statements work much like a Ruby case statement, except in that they leverage
the full power of Qo matchers behind the scenes.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># How about some &quot;right-hand assignment&quot; pattern matching
</span><span class='id identifier rubyid_name_longer_than_three'>name_longer_than_three</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_person'>person</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>3</span> <span class='rbrace'>}</span>

<span class='id identifier rubyid_person_with_truncated_name'>person_with_truncated_name</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_case'><span class='object_link'><a href="Qo/PublicApi.html#case-instance_method" title="Qo::PublicApi#case (method)">case</a></span></span><span class='lparen'>(</span><span class='id identifier rubyid_people'>people</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_m'>m</span><span class='op'>|</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_when'>when</span><span class='lparen'>(</span><span class='id identifier rubyid_name_longer_than_three'>name_longer_than_three</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span>
    <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='int'>2</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_age'>age</span><span class='rparen'>)</span>
  <span class='rbrace'>}</span>

  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_else'>else</span>
<span class='rbrace'>}</span>
</code></pre>

<p>It takes in a value directly, and returns the result, much like a case statement.</p>

<p>Note that if <code>else</code> receives no block, it will default to an identity function
(<code>{ |v| v }</code>). If no else is provided and there&#39;s no match, you&#39;ll get back a nil.
You can write this out if you wish.</p>

<h5>Match Statements</h5>

<p>Match statements are like case statements, except in that they don&#39;t directly take
a value to match against. They&#39;re waiting for a value to come in later from
something else.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_name_longer_than_three'>name_longer_than_three</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_person'>person</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>3</span> <span class='rbrace'>}</span>

<span class='id identifier rubyid_people_with_truncated_names'>people_with_truncated_names</span> <span class='op'>=</span> <span class='id identifier rubyid_people'>people</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_match'><span class='object_link'><a href="Qo/PublicApi.html#match-instance_method" title="Qo::PublicApi#match (method)">match</a></span></span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_m'>m</span><span class='op'>|</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_when'>when</span><span class='lparen'>(</span><span class='id identifier rubyid_name_longer_than_three'>name_longer_than_three</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span> <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='int'>2</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_age'>age</span><span class='rparen'>)</span> <span class='rbrace'>}</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_else'>else</span>
<span class='rbrace'>}</span><span class='rparen'>)</span>

<span class='comment'># And standalone like a case:
</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_match'><span class='object_link'><a href="Qo/PublicApi.html#match-instance_method" title="Qo::PublicApi#match (method)">match</a></span></span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_m'>m</span><span class='op'>|</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_when'>when</span><span class='lparen'>(</span><span class='label'>age:</span> <span class='int'>10</span><span class='op'>..</span><span class='int'>19</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'> is a teen that&#39;s </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_age'>age</span><span class='embexpr_end'>}</span><span class='tstring_content'> years old</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_else'>else</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'> is </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_age'>age</span><span class='embexpr_end'>}</span><span class='tstring_content'> years old</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
<span class='rbrace'>}</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span><span class='lparen'>(</span><span class='id identifier rubyid_people'>people</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='rparen'>)</span>
</code></pre>

<h3>Qo&#39;isms</h3>

<p>Qo supports three main types of queries: <code>and</code>, <code>or</code>, and <code>not</code>.</p>

<p>Most examples are written in terms of <code>and</code> and its alias <code>[]</code>. <code>[]</code> is mostly used for portable syntax:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Rob</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rbracket'>]</span>

<span class='comment'># ...is functionally the same as an and query, which uses `all?` to match
</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_and'><span class='object_link'><a href="Qo/PublicApi.html#and-instance_method" title="Qo::PublicApi#and (method)">and</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Rob</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rparen'>)</span>

<span class='comment'># This is shorthand for
</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Qo/Matchers.html" title="Qo::Matchers (module)">Matchers</a></span></span><span class='op'>::</span><span class='const'>BaseMatcher</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>and</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Rob</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rparen'>)</span>

<span class='comment'># An `or` matcher uses the same shorthand as `and` but uses `any?` behind the scenes instead:
</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Rob</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rparen'>)</span>

<span class='comment'># Same with not, except it uses `none?`
</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_not'><span class='object_link'><a href="Qo/PublicApi.html#not-instance_method" title="Qo::PublicApi#not (method)">not</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Rob</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rparen'>)</span>
</code></pre>

<p>Qo has a few Qo&#39;isms, mainly based around triple equals in Ruby. See the above articles for tutorials on that count.</p>

<p>We will assume the following data:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_people_arrays'>people_arrays</span> <span class='op'>=</span> <span class='lbracket'>[</span>
  <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Robert</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rbracket'>]</span><span class='comma'>,</span>
  <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Roberta</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rbracket'>]</span><span class='comma'>,</span>
  <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>42</span><span class='rbracket'>]</span><span class='comma'>,</span>
  <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Bar</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>18</span><span class='rbracket'>]</span>
<span class='rbracket'>]</span>

<span class='id identifier rubyid_people_objects'>people_objects</span> <span class='op'>=</span> <span class='lbracket'>[</span>
  <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Robert</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rparen'>)</span><span class='comma'>,</span>
  <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Roberta</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rparen'>)</span><span class='comma'>,</span>
  <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>42</span><span class='rparen'>)</span><span class='comma'>,</span>
  <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Bar</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>17</span><span class='rparen'>)</span><span class='comma'>,</span>
<span class='rbracket'>]</span>
</code></pre>

<h3>1 - Wildcard Matching</h3>

<p>Qo has a concept of a Wildcard, <code>Any</code>, which will match against any value</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Any</span><span class='comma'>,</span> <span class='const'>Any</span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Robert</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rbracket'>]</span> <span class='comment'># true
</span></code></pre>

<p>A single wildcard will match anything, and can frequently be used as an always true:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Any</span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='symbol'>:literally_anything_here</span>
</code></pre>

<h3>2 - Array Matching</h3>

<p>The first way a Qo matcher can be defined is by using <code>*varargs</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Qo/Matchers.html" title="Qo::Matchers (module)">Matchers</a></span></span><span class='op'>::</span><span class='const'>BaseMatcher</span><span class='lparen'>(</span><span class='id identifier rubyid_type'>type</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_varargs'>varargs</span><span class='comma'>,</span> <span class='op'>**</span><span class='id identifier rubyid_kwargs'>kwargs</span><span class='rparen'>)</span>
</code></pre>

<p>This gives us the <code>and</code> matcher shorthand for array matchers.</p>

<h4>2.1 - Array matched against an Array</h4>

<p>When an Array matcher is run against an Array, it will compare elements by index in the following priority:</p>

<ol>
<li>Does it case match (<code>===</code>)?</li>
<li>Does it have a predicate method by that name that matches?</li>
</ol>

<p>This functionality is left biased and permissive, meaning that if the right side of the argument is longer it will ignore those items in the match. If it&#39;s shorter? Not so much.</p>

<h5>2.1.1 - Case Match present</h5>

<p>We&#39;ve seen some case matching so far with <code>Range</code> and <code>Regex</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Standalone
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Rob</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='const'>Any</span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Robert</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rbracket'>]</span>
<span class='comment'># =&gt; true
</span>
<span class='comment'># Case statement
</span>
<span class='kw'>case</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Roberta</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rbracket'>]</span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Any</span><span class='comma'>,</span> <span class='int'>0</span><span class='op'>..</span><span class='int'>9</span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>child</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Any</span><span class='comma'>,</span> <span class='int'>10</span><span class='op'>..</span><span class='int'>19</span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>teen</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Any</span><span class='comma'>,</span> <span class='int'>20</span><span class='op'>..</span><span class='int'>99</span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>adult</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>else</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>not sure</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &#39;adult&#39;
</span>
<span class='comment'># Select
</span>
<span class='id identifier rubyid_people_arrays'>people_arrays</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Any</span><span class='comma'>,</span> <span class='int'>10</span><span class='op'>..</span><span class='int'>19</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [[&#39;Bar&#39;, 18]]
</span></code></pre>

<h5>2.1.2 - Predicate Method matched</h5>

<p>If no case match is found, it will attempt to see if a predicate method by the same name exists, call it, and check the result:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_dirty_values'>dirty_values</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>true</span><span class='rbracket'>]</span>

<span class='comment'># Standalone
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='symbol'>:nil?</span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='lbracket'>[</span><span class='kw'>nil</span><span class='rbracket'>]</span>
<span class='comment'># =&gt; true, though you could also just use Qo[nil]
</span>
<span class='comment'># Case statement
</span>
<span class='kw'>case</span> <span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Roberta</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rbracket'>]</span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Any</span><span class='comma'>,</span> <span class='symbol'>:nil?</span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>no age</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>else</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>not sure</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &#39;no age&#39;
</span>
<span class='comment'># Select
</span>
<span class='id identifier rubyid_people_arrays'>people_arrays</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Any</span><span class='comma'>,</span> <span class='symbol'>:even?</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [[&quot;Robert&quot;, 22], [&quot;Roberta&quot;, 22], [&quot;Foo&quot;, 42], [&quot;Bar&quot;, 18]]
</span></code></pre>

<h4>2.2 - Array matched against an Object</h4>

<p>When an Array matcher is matched against anything other than an Array it will follow the priority:</p>

<ol>
<li>Does it case match (<code>===</code>)?</li>
<li>Does it have a predicate method by that name that matches?</li>
</ol>

<p>Every argument provided will be run against the target object.</p>

<h5>2.2.1 - Case Match present</h5>

<pre class="code ruby"><code class="ruby"><span class='comment'># Standalone
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Integer</span><span class='comma'>,</span> <span class='int'>15</span><span class='op'>..</span><span class='int'>25</span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='int'>20</span>
<span class='comment'># =&gt; true
</span>
<span class='comment'># Case statement - functionally indistinguishable from a regular case statement
</span>
<span class='comment'># Select
</span>
<span class='lbracket'>[</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>10</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>string</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>str</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>10</span><span class='op'>..</span><span class='int'>20</span><span class='rparen'>)</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [10, &quot;string&quot;]
</span></code></pre>

<h5>2.2.2 - Predicate Method matched</h5>

<p>Now this is where some of the fun starts in</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Standalone
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='symbol'>:nil?</span><span class='comma'>,</span> <span class='symbol'>:empty?</span><span class='rparen'>)</span> <span class='op'>===</span> <span class='kw'>nil</span>
<span class='comment'># =&gt; true
</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_not'><span class='object_link'><a href="Qo/PublicApi.html#not-instance_method" title="Qo::PublicApi#not (method)">not</a></span></span><span class='lparen'>(</span><span class='symbol'>:nil?</span><span class='comma'>,</span> <span class='symbol'>:empty?</span><span class='rparen'>)</span> <span class='op'>===</span> <span class='kw'>nil</span>
<span class='comment'># =&gt; false
</span>
<span class='comment'># Case statement
</span>
<span class='kw'>case</span> <span class='int'>42</span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:even?</span><span class='comma'>,</span> <span class='int'>40</span><span class='op'>..</span><span class='int'>50</span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>oddly specific number criteria</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>else</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>nope</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &quot;oddly specific number criteria&quot;
</span>
<span class='comment'># Reject
</span>
<span class='lbracket'>[</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>10</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>string</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_reject'>reject</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='symbol'>:nil?</span><span class='comma'>,</span> <span class='symbol'>:empty?</span><span class='rparen'>)</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [10, &quot;string&quot;]
</span></code></pre>

<h3>3 - Hash Matching</h3>

<h4>3.1 - Hash matched against a Hash</h4>

<ol>
<li>Does the key exist on the other hash?</li>
<li>Are the match value and match target hashes?</li>
<li>Does the target object&#39;s value case match against the match value?</li>
<li>Does the target object&#39;s value predicate match against the match value?</li>
<li>What about the String version of the match key? Abort if it can&#39;t coerce.</li>
</ol>

<h5>3.1.1 - Key present</h5>

<p>Checks to see if the key is even present on the other object, false if not.</p>

<h5>3.1.2 - Match value and target are hashes</h5>

<p>If both the match value (<code>match_key: matcher</code>) and the match target are hashes, Qo will begin a recursive descent starting at the match key until it finds a matcher to try out:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>a:</span> <span class='lbrace'>{</span><span class='label'>b:</span> <span class='lbrace'>{</span><span class='label'>c:</span> <span class='int'>5</span><span class='op'>..</span><span class='int'>15</span><span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='lbrace'>{</span><span class='label'>a:</span> <span class='lbrace'>{</span><span class='label'>b:</span> <span class='lbrace'>{</span><span class='label'>c:</span> <span class='int'>10</span><span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rbrace'>}</span>
<span class='comment'># =&gt; true
</span>
<span class='comment'># Na, no fun. Deeper!
</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_and'><span class='object_link'><a href="Qo/PublicApi.html#and-instance_method" title="Qo::PublicApi#and (method)">and</a></span></span><span class='lparen'>(</span><span class='label'>a:</span> <span class='lbrace'>{</span>
  <span class='label'>f:</span> <span class='int'>5</span><span class='op'>..</span><span class='int'>15</span><span class='comma'>,</span>
  <span class='label'>b:</span> <span class='lbrace'>{</span>
    <span class='label'>c:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/</span></span><span class='comma'>,</span>
    <span class='label'>d:</span> <span class='int'>10</span><span class='op'>..</span><span class='int'>30</span>
  <span class='rbrace'>}</span>
<span class='rbrace'>}</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span><span class='lparen'>(</span><span class='label'>a:</span> <span class='lbrace'>{</span>
  <span class='label'>f:</span> <span class='int'>10</span><span class='comma'>,</span>
  <span class='label'>b:</span> <span class='lbrace'>{</span>
    <span class='label'>c:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foobar</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
    <span class='label'>d:</span> <span class='int'>20</span>
  <span class='rbrace'>}</span>
<span class='rbrace'>}</span><span class='rparen'>)</span>
<span class='comment'># =&gt; true
</span>
<span class='comment'># It can get chaotic with `or` though. Anything anywhere in there matches and
</span><span class='comment'># it&#39;ll pass.
</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='label'>a:</span> <span class='lbrace'>{</span>
  <span class='label'>f:</span> <span class='kw'>false</span><span class='comma'>,</span>
  <span class='label'>b:</span> <span class='lbrace'>{</span>
    <span class='label'>c:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>nope</span><span class='regexp_end'>/</span></span><span class='comma'>,</span>
    <span class='label'>d:</span> <span class='int'>10</span><span class='op'>..</span><span class='int'>30</span>
  <span class='rbrace'>}</span>
<span class='rbrace'>}</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span><span class='lparen'>(</span><span class='label'>a:</span> <span class='lbrace'>{</span>
  <span class='label'>f:</span> <span class='int'>10</span><span class='comma'>,</span>
  <span class='label'>b:</span> <span class='lbrace'>{</span>
    <span class='label'>c:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>foobar</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
    <span class='label'>d:</span> <span class='int'>20</span>
  <span class='rbrace'>}</span>
<span class='rbrace'>}</span><span class='rparen'>)</span>
</code></pre>

<h5>3.1.3 - Case match present</h5>

<p>If a case match is present for the key, it&#39;ll try and compare:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Standalone
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Foo</span><span class='regexp_end'>/</span></span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='lbrace'>{</span><span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Foo</span><span class='tstring_end'>&#39;</span></span><span class='rbrace'>}</span>
<span class='comment'># =&gt; true
</span>
<span class='comment'># Case statement
</span>
<span class='kw'>case</span> <span class='lbrace'>{</span><span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>age:</span> <span class='int'>42</span><span class='rbrace'>}</span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>age:</span> <span class='int'>40</span><span class='op'>..</span><span class='int'>50</span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Gotcha!</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>else</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>nope</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &quot;Gotcha!&quot;
</span>
<span class='comment'># Select
</span>
<span class='id identifier rubyid_people_hashes'>people_hashes</span> <span class='op'>=</span> <span class='id identifier rubyid_people_arrays'>people_arrays</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_n'>n</span><span class='comma'>,</span> <span class='id identifier rubyid_a'>a</span><span class='op'>|</span> <span class='lbrace'>{</span><span class='label'>name:</span> <span class='id identifier rubyid_n'>n</span><span class='comma'>,</span> <span class='label'>age:</span> <span class='id identifier rubyid_a'>a</span><span class='rbrace'>}</span> <span class='rbrace'>}</span>
<span class='id identifier rubyid_people_hashes'>people_hashes</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>age:</span> <span class='int'>15</span><span class='op'>..</span><span class='int'>25</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [{:name=&gt;&quot;Robert&quot;, :age=&gt;22}, {:name=&gt;&quot;Roberta&quot;, :age=&gt;22}, {:name=&gt;&quot;Bar&quot;, :age=&gt;18}]
</span></code></pre>

<h5>3.1.4 - Predicate match present</h5>

<p>Much like our array friend above, if a predicate style method is present see if it&#39;ll work</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Standalone
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>name:</span> <span class='symbol'>:empty?</span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='lbrace'>{</span><span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span><span class='rbrace'>}</span>
<span class='comment'># =&gt; true
</span>
<span class='comment'># Case statement
</span>
<span class='kw'>case</span> <span class='lbrace'>{</span><span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Foo</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>age:</span> <span class='kw'>nil</span><span class='rbrace'>}</span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>age:</span> <span class='symbol'>:nil?</span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>No age provided!</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>else</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>nope</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &quot;No age provided!&quot;
</span>
<span class='comment'># Reject
</span>
<span class='id identifier rubyid_people_hashes'>people_hashes</span> <span class='op'>=</span> <span class='id identifier rubyid_people_arrays'>people_arrays</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='lparen'>(</span><span class='id identifier rubyid_n'>n</span><span class='comma'>,</span><span class='id identifier rubyid_a'>a</span><span class='rparen'>)</span><span class='op'>|</span> <span class='lbrace'>{</span><span class='label'>name:</span> <span class='id identifier rubyid_n'>n</span><span class='comma'>,</span> <span class='label'>age:</span> <span class='id identifier rubyid_a'>a</span><span class='rbrace'>}</span> <span class='rbrace'>}</span> <span class='op'>&lt;&lt;</span> <span class='lbrace'>{</span><span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Ghost</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>age:</span> <span class='kw'>nil</span><span class='rbrace'>}</span>
<span class='id identifier rubyid_people_hashes'>people_hashes</span><span class='period'>.</span><span class='id identifier rubyid_reject'>reject</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>age:</span> <span class='symbol'>:nil?</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [{:name=&gt;&quot;Robert&quot;, :age=&gt;22}, {:name=&gt;&quot;Roberta&quot;, :age=&gt;22}, {:name=&gt;&quot;Bar&quot;, :age=&gt;18}]
</span></code></pre>

<p>Careful though, if the key doesn&#39;t exist that won&#39;t match. I&#39;ll have to consider this one later.</p>

<h5>3.1.5 - String variant present</h5>

<p>Coerces the key into a string if possible, and sees if that can provide a valid case match</p>

<h4>3.2 - Hash matched against an Object</h4>

<ol>
<li>Does the object respond to the match key?</li>
<li>Does the result of sending the match key as a method case match the provided value?</li>
<li>Does a predicate method exist for it?</li>
</ol>

<h5>3.2.1 - Responds to match key</h5>

<p>If it doesn&#39;t know how to deal with it, false out.</p>

<h5>3.2.2 - Case match present</h5>

<p>This is where we can get into some interesting code, much like the hash selections above</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Standalone
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Rob</span><span class='regexp_end'>/</span></span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='id identifier rubyid_people_objects'>people_objects</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span>
<span class='comment'># =&gt; true
</span>
<span class='comment'># Case statement
</span>
<span class='kw'>case</span> <span class='id identifier rubyid_people_objects'>people_objects</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Rob</span><span class='regexp_end'>/</span></span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>It&#39;s Rob!</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Na, not them</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &quot;It&#39;s Rob!&quot;
</span>
<span class='comment'># Select
</span>
<span class='id identifier rubyid_people_objects'>people_objects</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>name:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Rob</span><span class='regexp_end'>/</span></span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='comment'># =&gt; [Person(Robert, 22), Person(Roberta, 22)]
</span></code></pre>

<h5>3.2.3 - Predicate match present</h5>

<pre class="code ruby"><code class="ruby"><span class='comment'># Standalone
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>name:</span> <span class='symbol'>:empty?</span><span class='rbracket'>]</span> <span class='op'>===</span> <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rparen'>)</span>
<span class='comment'># =&gt; true
</span>
<span class='comment'># Case statement
</span>
<span class='kw'>case</span> <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>nil</span><span class='rparen'>)</span>
<span class='kw'>when</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>age:</span> <span class='symbol'>:nil?</span><span class='rbracket'>]</span> <span class='kw'>then</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>No age provided!</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>else</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>nope</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
<span class='comment'># =&gt; &quot;No age provided!&quot;
</span>
<span class='comment'># Select
</span>
<span class='id identifier rubyid_people_hashes'>people_hashes</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>age:</span> <span class='symbol'>:nil?</span><span class='rbracket'>]</span><span class='rparen'>)</span>
<span class='comment'># =&gt; []
</span></code></pre>

<h3>4 - Right Hand Pattern Matching</h3>

<p>This is where I start going a bit off into the weeds. We&#39;re going to try and get RHA style pattern matching in Ruby.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_case'><span class='object_link'><a href="Qo/PublicApi.html#case-instance_method" title="Qo::PublicApi#case (method)">case</a></span></span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Robert</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='int'>22</span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_m'>m</span><span class='op'>|</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_when'>when</span><span class='lparen'>(</span><span class='const'>Any</span><span class='comma'>,</span> <span class='int'>20</span><span class='op'>..</span><span class='int'>99</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_n'>n</span><span class='comma'>,</span> <span class='id identifier rubyid_a'>a</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_n'>n</span><span class='embexpr_end'>}</span><span class='tstring_content'> is an adult that is </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_a'>a</span><span class='embexpr_end'>}</span><span class='tstring_content'> years old</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_else'>else</span>
<span class='rbrace'>}</span>
<span class='comment'># =&gt; &quot;Robert is an adult that is 22 years old&quot;
</span></code></pre>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_case'><span class='object_link'><a href="Qo/PublicApi.html#case-instance_method" title="Qo::PublicApi#case (method)">case</a></span></span><span class='lparen'>(</span><span class='id identifier rubyid_people_objects'>people_objects</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_m'>m</span><span class='op'>|</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_when'>when</span><span class='lparen'>(</span><span class='label'>name:</span> <span class='const'>Any</span><span class='comma'>,</span> <span class='label'>age:</span> <span class='int'>20</span><span class='op'>..</span><span class='int'>99</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'> is an adult that is </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_age'>age</span><span class='embexpr_end'>}</span><span class='tstring_content'> years old</span><span class='tstring_end'>&quot;</span></span> <span class='rbrace'>}</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_else'>else</span>
<span class='rbrace'>}</span>
</code></pre>

<p>In this case it&#39;s trying to do a few things:</p>

<ol>
<li>Iterate over every matcher until it finds a match</li>
<li>Execute its block function</li>
</ol>

<p>If no block function is provided, it assumes an identity function (<code>-&gt; v { v }</code>) instead. If no match is found, <code>nil</code> will be returned.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_name_longer_than_three'>name_longer_than_three</span> <span class='op'>=</span> <span class='tlambda'>-&gt;</span> <span class='id identifier rubyid_person'>person</span> <span class='tlambeg'>{</span> <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_size'>size</span> <span class='op'>&gt;</span> <span class='int'>3</span> <span class='rbrace'>}</span>

<span class='id identifier rubyid_people_objects'>people_objects</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_match'><span class='object_link'><a href="Qo/PublicApi.html#match-instance_method" title="Qo::PublicApi#match (method)">match</a></span></span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_m'>m</span><span class='op'>|</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_when'>when</span><span class='lparen'>(</span><span class='id identifier rubyid_name_longer_than_three'>name_longer_than_three</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_person'>person</span><span class='op'>|</span> <span class='const'>Person</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='lbracket'>[</span><span class='int'>0</span><span class='op'>..</span><span class='int'>2</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='id identifier rubyid_person'>person</span><span class='period'>.</span><span class='id identifier rubyid_age'>age</span><span class='rparen'>)</span> <span class='rbrace'>}</span>

  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_else'>else</span>
<span class='rbrace'>}</span><span class='rparen'>)</span>

<span class='comment'># =&gt; [Person(age: 22, name: &quot;Rob&quot;), Person(age: 22, name: &quot;Rob&quot;), Person(age: 42, name: &quot;Foo&quot;), Person(age: 17, name: &quot;Bar&quot;)]
</span></code></pre>

<p>So we just truncated everyone&#39;s name that was longer than three characters.</p>

<h3>5 - Helper functions</h3>

<p>There are a few functions added for convenience, and it should be noted that because all Qo matchers respond to <code>===</code> that they can be used as helpers as well.</p>

<h4>5.1 - Dig</h4>

<p>Dig is used to get in deep at a nested hash value. It takes a dot-path and a <code>===</code> respondent matcher:</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_dig'>dig</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a.b.c</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='int'>1</span><span class='op'>..</span><span class='int'>5</span><span class='comma'>,</span> <span class='int'>15</span><span class='op'>..</span><span class='int'>25</span><span class='rparen'>)</span><span class='rparen'>)</span> <span class='op'>===</span> <span class='lbrace'>{</span><span class='label'>a:</span> <span class='lbrace'>{</span><span class='label'>b:</span> <span class='lbrace'>{</span><span class='label'>c:</span> <span class='int'>1</span><span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rbrace'>}</span>
<span class='comment'># =&gt; true
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_dig'>dig</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a.b.c</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='int'>1</span><span class='op'>..</span><span class='int'>5</span><span class='comma'>,</span> <span class='int'>15</span><span class='op'>..</span><span class='int'>25</span><span class='rparen'>)</span><span class='rparen'>)</span> <span class='op'>===</span> <span class='lbrace'>{</span><span class='label'>a:</span> <span class='lbrace'>{</span><span class='label'>b:</span> <span class='lbrace'>{</span><span class='label'>c:</span> <span class='int'>20</span><span class='rbrace'>}</span><span class='rbrace'>}</span><span class='rbrace'>}</span>
<span class='comment'># =&gt; true
</span></code></pre>

<p>To be fair that means anything that can respond to <code>===</code>, including classes and other such things.</p>

<h4>5.2 - Count By</h4>

<p>This ends up coming up a lot, especially around querying, so let&#39;s get a way to count by!</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_count_by'>count_by</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='int'>1</span><span class='comma'>,</span><span class='int'>2</span><span class='comma'>,</span><span class='int'>3</span><span class='comma'>,</span><span class='int'>2</span><span class='comma'>,</span><span class='int'>2</span><span class='comma'>,</span><span class='int'>2</span><span class='comma'>,</span><span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span>

<span class='comment'># =&gt; {
</span><span class='comment'>#   1 =&gt; 2,
</span><span class='comment'>#   2 =&gt; 4,
</span><span class='comment'>#   3 =&gt; 1
</span><span class='comment'># }
</span>
<span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_count_by'>count_by</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='int'>1</span><span class='comma'>,</span><span class='int'>2</span><span class='comma'>,</span><span class='int'>3</span><span class='comma'>,</span><span class='int'>2</span><span class='comma'>,</span><span class='int'>2</span><span class='comma'>,</span><span class='int'>2</span><span class='comma'>,</span><span class='int'>1</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='symbol'>:even?</span><span class='rparen'>)</span>

<span class='comment'># =&gt; {
</span><span class='comment'>#   false =&gt; 3,
</span><span class='comment'>#   true  =&gt; 4
</span><span class='comment'># }
</span></code></pre>

<p>This feature may be added to Ruby 2.6+: <a href="https://bugs.ruby-lang.org/issues/11076">https://bugs.ruby-lang.org/issues/11076</a></p>

<h3>6 - Custom Pattern Matchers</h3>

<p>With the release of Qo 1.0.0 we introduced the idea of custom branches and pattern matchers for more advanced
users of the library.</p>

<p>Consider a Monadic type like <code>Some</code> and <code>None</code>:</p>

<pre class="code ruby"><code class="ruby"># Technically Some and None don&#39;t exist yet, so we have to &quot;cheat&quot; instead
# of just saying `Some` for the precondition
#
# We start by defining two branches that match against a Some type and a None
# type, extracting the value on match before yielding to their associated
# functions
SomeBranch = Qo.create_branch(
  name:        &#39;some&#39;,
  precondition: -&gt; v { v.is_a?(Some) },
  extractor:    :value
)

NoneBranch = Qo.create_branch(
  name:        &#39;none&#39;,
  precondition: -&gt; v { v.is_a?(None) },
  extractor:    :value
)

# Now we create a new pattern matching class with those branches. Note that
# there&#39;s nothing stopping you from making as many branches as you want,
# except that it may get confusing after a while.
SomePatternMatch = Qo.create_pattern_match(branches: [
  SomeBranch,
  NoneBranch
])

class Some
  # There&#39;s also a provided mixin that gives an `match` method that
  # works exactly like a pattern match without having to use it explicitly
  include SomePatternMatch.mixin

  attr_reader :value

  def initialize(value) @value = value end
  def self.[](value)    new(value)     end

  def fmap(&amp;fn)
    new_value = fn.call(value)
    new_value ? Some[new_value] : None[value]
  end
end

class None
  include SomePatternMatch.mixin

  attr_reader :value

  def initialize(value) @value = value end
  def self.[](value)    new(value)     end

  def fmap(&amp;fn) None[value] end
end

# So now we can pattern match with `some` and `none` branches using the `match`
# method that was mixed into both types.
Some[1]
  .fmap { |v| v * 2 }
  .match { |m|
    m.some { |v| v + 100 }
    m.none { &quot;OHNO!&quot; }
  }
=&gt; 102

Some[1]
  .fmap { |v| nil }
  .match { |m|
    m.some { |v| v + 100 }
    m.none { &quot;OHNO!&quot; }
  }
=&gt; &quot;OHNO!&quot;
</code></pre>

<h3>7 - Hacky Fun Time</h3>

<p>These examples will grow over the next few weeks as I think of more fun things to do with Qo. PRs welcome if you find fun uses!</p>

<h4>7.1 - JSON and HTTP</h4>

<blockquote>
<p>Note that Qo does not support deep querying of hashes (yet)</p>
</blockquote>

<h5>7.1.1 - JSON Placeholder</h5>

<p>Qo tries to be clever though, it assumes Symbol keys first and then String keys, so how about some JSON?:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>json</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>net/http</span><span class='tstring_end'>&#39;</span></span>

<span class='id identifier rubyid_posts'>posts</span> <span class='op'>=</span> <span class='const'>JSON</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span>
  <span class='const'>Net</span><span class='op'>::</span><span class='const'>HTTP</span><span class='period'>.</span><span class='id identifier rubyid_get'>get</span><span class='lparen'>(</span><span class='const'>URI</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>https://jsonplaceholder.typicode.com/posts</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='label'>symbolize_names:</span> <span class='kw'>true</span>
<span class='rparen'>)</span>

<span class='id identifier rubyid_users'>users</span> <span class='op'>=</span> <span class='const'>JSON</span><span class='period'>.</span><span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span>
  <span class='const'>Net</span><span class='op'>::</span><span class='const'>HTTP</span><span class='period'>.</span><span class='id identifier rubyid_get'>get</span><span class='lparen'>(</span><span class='const'>URI</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>https://jsonplaceholder.typicode.com/users</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='label'>symbolize_names:</span> <span class='kw'>true</span>
<span class='rparen'>)</span>

<span class='comment'># Get all posts where the userId is 1.
</span><span class='id identifier rubyid_posts'>posts</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='lbracket'>[</span><span class='label'>userId:</span> <span class='int'>1</span><span class='rbracket'>]</span><span class='rparen'>)</span>

<span class='comment'># Get users named Nicholas or have two names and an address somewhere with a zipcode
</span><span class='comment'># that starts with 9 or 4.
</span><span class='comment'>#
</span><span class='comment'># Qo matchers return a `===` respondant object, remember, so we can totally nest them.
</span><span class='id identifier rubyid_users'>users</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_and'><span class='object_link'><a href="Qo/PublicApi.html#and-instance_method" title="Qo::PublicApi#and (method)">and</a></span></span><span class='lparen'>(</span>
  <span class='label'>name:</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^Nicholas</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^\w+ \w+$</span><span class='regexp_end'>/</span></span><span class='rparen'>)</span><span class='comma'>,</span>
  <span class='label'>address:</span> <span class='lbrace'>{</span>
    <span class='label'>zipcode:</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^9</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^4</span><span class='regexp_end'>/</span></span><span class='rparen'>)</span>
  <span class='rbrace'>}</span>
<span class='rparen'>)</span><span class='rparen'>)</span>

<span class='comment'># We could even use dig to get at some of the same information. This and the above will
</span><span class='comment'># return the same results even.
</span><span class='id identifier rubyid_users'>users</span><span class='period'>.</span><span class='id identifier rubyid_select'>select</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_and'><span class='object_link'><a href="Qo/PublicApi.html#and-instance_method" title="Qo::PublicApi#and (method)">and</a></span></span><span class='lparen'>(</span>
  <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_dig'>dig</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>address.zipcode</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^9</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^4</span><span class='regexp_end'>/</span></span><span class='rparen'>)</span><span class='rparen'>)</span><span class='comma'>,</span>
  <span class='label'>name:</span> <span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_or'><span class='object_link'><a href="Qo/PublicApi.html#or-instance_method" title="Qo::PublicApi#or (method)">or</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^Nicholas</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^\w+ \w+$</span><span class='regexp_end'>/</span></span><span class='rparen'>)</span>
<span class='rparen'>)</span><span class='rparen'>)</span>
</code></pre>

<p>Nifty!</p>

<h5>Yield Self HTTP status matching</h5>

<p>You can even use <code>#yield_self</code> to pipe values into a pattern matching block. In
this particular case it&#39;ll let you check against the type signatures of the
HTTP responses.</p>

<pre class="code ruby"><code class="ruby">def get_url(url)
  Net::HTTP.get_response(URI(url)).yield_self(&amp;Qo.match { |m|
    m.when(Net::HTTPSuccess) { |response| response.body.size },
    m.else                   { |response| raise response.message }
  })
end

get_url(&#39;https://github.com/baweaver/qo&#39;)
# =&gt; 142387
get_url(&#39;https://github.com/baweaver/qo/does_not_exist&#39;)
# =&gt; RuntimeError: Not Found
</code></pre>

<p>The difference between this and case? Well, the first is you can pass this to
<code>yield_self</code> for a more inline solution. The second is that any Qo matcher can
be used in there, including predicate and content checks on the body:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_when'>when</span><span class='lparen'>(</span><span class='const'>Net</span><span class='op'>::</span><span class='const'>HTTPSuccess</span><span class='comma'>,</span> <span class='label'>body:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Qo</span><span class='regexp_end'>/</span></span><span class='rparen'>)</span>
</code></pre>

<p>You could put as many checks as you want in there, or use different Qo matchers
nested to get even further in.</p>

<p>Now if we wanted to add more power and create an HTTP matcher:</p>

<pre class="code ruby"><code class="ruby">HTTP_Matcher = Qo.create_pattern_match(branches: [
  Qo.create_branch(name: &#39;success&#39;, precondition: Net::HTTPSuccess),
  Qo.create_branch(name: &#39;error&#39;, precondition: Net::HTTPError),
  Qo::Braches::ElseBranch
])

def get_url(url)
  Net::HTTP.get_response(URI(url)).then(&amp;HTTP_Matcher.match { |m|
    m.success { |response| response.body.size },
    m.else    { |response| raise response.message }
  })
end
</code></pre>

<h4>7.2 - Opsy Stuff</h4>

<h5>7.2.1 - NMap</h5>

<p>What about NMap for our Opsy friends? Well, simulated, but still fun.</p>

<pre class="code ruby"><code class="ruby">hosts = (`nmap -oG - -sP 192.168.1.* 10.0.0.* | grep Host`).lines.map { |v| v.split[1..2] }
=&gt; [[&quot;192.168.1.1&quot;, &quot;(Router)&quot;], [&quot;192.168.1.2&quot;, &quot;(My Computer)&quot;], [&quot;10.0.0.1&quot;, &quot;(Gateway)&quot;]]

hosts.select(&amp;Qo[IPAddr.new(&#39;192.168.1.1/8&#39;)])
=&gt; [[&quot;192.168.1.1&quot;, &quot;(Router)&quot;], [&quot;192.168.1.2&quot;, &quot;(My Computer)&quot;]]
</code></pre>

<h5>7.2.2 - <code>df</code></h5>

<p>The nice thing about Unix style commands is that they use headers, which means CSV can get a hold of them for some good formatting. It&#39;s also smart enough to deal with space separators that may vary in length:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rows'>rows</span> <span class='op'>=</span> <span class='const'>CSV</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>df -h</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='label'>col_sep:</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'> </span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='label'>headers:</span> <span class='kw'>true</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_read'>read</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:to_h</span><span class='rparen'>)</span>

<span class='id identifier rubyid_rows'>rows</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='const'><span class='object_link'><a href="Qo.html" title="Qo (module)">Qo</a></span></span><span class='period'>.</span><span class='id identifier rubyid_match'><span class='object_link'><a href="Qo/PublicApi.html#match-instance_method" title="Qo::PublicApi#match (method)">match</a></span></span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_m'>m</span><span class='op'>|</span>
  <span class='id identifier rubyid_m'>m</span><span class='period'>.</span><span class='id identifier rubyid_when'>when</span><span class='lparen'>(</span><span class='label'>Avail:</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>Gi$</span><span class='regexp_end'>/</span></span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_row'>row</span><span class='op'>|</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_row'>row</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Filesystem</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='embexpr_end'>}</span><span class='tstring_content'> mounted on </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_row'>row</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Mounted</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='embexpr_end'>}</span><span class='tstring_content'> [</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_row'>row</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Avail</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='embexpr_end'>}</span><span class='tstring_content'> / </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_row'>row</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Size</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='embexpr_end'>}</span><span class='tstring_content'>]</span><span class='tstring_end'>&quot;</span></span>
  <span class='rbrace'>}</span>
<span class='rbrace'>}</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_compact'>compact</span>
<span class='comment'># =&gt; [&quot;/dev/***** mounted on / [186Gi / 466Gi]&quot;]
</span></code></pre>

<h2>Installation</h2>

<p>Add this line to your application&#39;s Gemfile:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>qo</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>And then execute:</p>

<pre class="code ruby"><code class="ruby">$ bundle
</code></pre>

<p>Or install it yourself as:</p>

<pre class="code ruby"><code class="ruby">$ gem install qo
</code></pre>

<h2>Development</h2>

<p>After checking out the repo, run <code>bin/setup</code> to install dependencies. Then, run <code>rake spec</code> to run the tests. You can also run <code>bin/console</code> for an interactive prompt that will allow you to experiment.</p>

<p>To install this gem onto your local machine, run <code>bundle exec rake install</code>. To release a new version, update the version number in <code>version.rb</code>, and then run <code>bundle exec rake release</code>, which will create a git tag for the version, push git commits and tags, and push the <code>.gem</code> file to <a href="https://rubygems.org">rubygems.org</a>.</p>

<h2>Contributing</h2>

<p>Bug reports and pull requests are welcome on GitHub at <a href="https://github.com/baweaver/qo">https://github.com/baweaver/qo</a>. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the <a href="http://contributor-covenant.org">Contributor Covenant</a> code of conduct.</p>

<h2>License</h2>

<p>The gem is available as open source under the terms of the <a href="http://opensource.org/licenses/MIT">MIT License</a>.</p>

<h2>Code of Conduct</h2>

<p>Everyone interacting in the Qo projects codebases, issue trackers, chat rooms and mailing lists is expected to follow the <a href="https://github.com/baweaver/qo/blob/master/CODE_OF_CONDUCT.md">code of conduct</a>.</p>
</div></div>

      <div id="footer">
  Generated on Mon Feb 18 01:59:30 2019 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.12 (ruby-2.6.1).
</div>

    </div>
  </body>
</html>